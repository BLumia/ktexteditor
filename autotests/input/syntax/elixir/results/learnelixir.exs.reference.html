<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="Generator" content="Kate, the KDE Advanced Text Editor" />
<title>learnelixir.exs</title>
</head>
<!-- Highlighting: "Elixir" -->
<body>
<pre style='font-weight:bold;color:#232627;background-color:#fcfcfc;'>
<span style='color:#7f8c8d;'># Original: https://learnxinyminutes.com/docs/elixir/</span>

<span style='color:#7f8c8d;'># Single line comments start with a number symbol.</span>

<span style='color:#7f8c8d;'># There's no multi-line comment,</span>
<span style='color:#7f8c8d;'># but you can stack multiple comments.</span>

<span style='color:#7f8c8d;'># To use the elixir shell use the `iex` command.</span>
<span style='color:#7f8c8d;'># Compile your modules with the `elixirc` command.</span>

<span style='color:#7f8c8d;'># Both should be in your path if you installed elixir correctly.</span>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Basic types</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># There are numbers</span>
<span style='color:#f67400;'>3</span>    <span style='color:#7f8c8d;'># integer</span>
<span style='color:#f67400;'>0x1F</span> <span style='color:#7f8c8d;'># integer</span>
<span style='color:#f67400;'>3.0</span>  <span style='color:#7f8c8d;'># float</span>

<span style='color:#7f8c8d;'># Atoms, that are literals, a constant with name. They start with `:`.</span>
<span style='color:#2980b9;'>:hello</span> <span style='color:#7f8c8d;'># atom</span>

<span style='color:#7f8c8d;'># Tuples that are stored contiguously in memory.</span>
{<span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span>} <span style='color:#7f8c8d;'># tuple</span>

<span style='color:#7f8c8d;'># We can access a tuple element with the `elem` function:</span>
elem({<span style='color:#f67400;'>1</span>, <span style='color:#f67400;'>2</span>, <span style='color:#f67400;'>3</span>}, <span style='color:#f67400;'>0</span>) <span style='color:#7f8c8d;'>#=&gt; 1</span>

<span style='color:#7f8c8d;'># Lists that are implemented as linked lists.</span>
<span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span><span style='color:#ff9fec;'>]</span> <span style='color:#7f8c8d;'># list</span>

<span style='color:#7f8c8d;'># We can access the head and tail of a list as follows:</span>
<span style='color:#ff9fec;'>[</span>head | tail<span style='color:#ff9fec;'>]</span> = <span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span><span style='color:#ff9fec;'>]</span>
head <span style='color:#7f8c8d;'>#=&gt; 1</span>
tail <span style='color:#7f8c8d;'>#=&gt; [2,3]</span>

<span style='color:#7f8c8d;'># In elixir, just like in Erlang, the `=` denotes pattern matching and</span>
<span style='color:#7f8c8d;'># not an assignment.</span>
<span style='color:#7f8c8d;'>#</span>
<span style='color:#7f8c8d;'># This means that the left-hand side (pattern) is matched against a</span>
<span style='color:#7f8c8d;'># right-hand side.</span>
<span style='color:#7f8c8d;'>#</span>
<span style='color:#7f8c8d;'># This is how the above example of accessing the head and tail of a list works.</span>

<span style='color:#7f8c8d;'># A pattern match will error when the sides don't match, in this example</span>
<span style='color:#7f8c8d;'># the tuples have different sizes.</span>
<span style='color:#7f8c8d;'># {a, b, c} = {1, 2} #=&gt; ** (MatchError) no match of right hand side value: {1,2}</span>

<span style='color:#7f8c8d;'># There are also binaries</span>
&lt;&lt;<span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span>&gt;&gt; <span style='color:#7f8c8d;'># binary</span>

<span style='color:#7f8c8d;'># Strings and char lists</span>
<span style='color:#da4453;'>&quot;hello&quot;</span> <span style='color:#7f8c8d;'># string</span>
<span style='color:#da4453;'>'hello'</span> <span style='color:#7f8c8d;'># char list</span>

<span style='color:#7f8c8d;'># Multi-line strings</span>
<span style='color:#da4453;'>&quot;&quot;&quot;</span>
<span style='color:#da4453;'>I'm a multi-line</span>
<span style='color:#da4453;'>string.</span>
<span style='color:#da4453;'>&quot;&quot;&quot;</span>
<span style='color:#7f8c8d;'>#=&gt; &quot;I'm a multi-line\nstring.\n&quot;</span>

<span style='color:#7f8c8d;'># Strings are all encoded in UTF-8:</span>
<span style='color:#da4453;'>&quot;héllò&quot;</span> <span style='color:#7f8c8d;'>#=&gt; &quot;héllò&quot;</span>

<span style='color:#7f8c8d;'># Strings are really just binaries, and char lists are just lists.</span>
&lt;&lt;?a, ?b, ?c&gt;&gt; <span style='color:#7f8c8d;'>#=&gt; &quot;abc&quot;</span>
<span style='color:#ff9fec;'>[</span>?a, ?b, ?c<span style='color:#ff9fec;'>]</span>   <span style='color:#7f8c8d;'>#=&gt; 'abc'</span>

<span style='color:#7f8c8d;'># `?a` in elixir returns the ASCII integer for the letter `a`</span>
?a <span style='color:#7f8c8d;'>#=&gt; 97</span>

<span style='color:#7f8c8d;'># To concatenate lists use `++`, for binaries use `&lt;&gt;`</span>
<span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span><span style='color:#ff9fec;'>]</span> ++ <span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>4</span>,<span style='color:#f67400;'>5</span><span style='color:#ff9fec;'>]</span>     <span style='color:#7f8c8d;'>#=&gt; [1,2,3,4,5]</span>
<span style='color:#da4453;'>'hello '</span> ++ <span style='color:#da4453;'>'world'</span>  <span style='color:#7f8c8d;'>#=&gt; 'hello world'</span>

&lt;&lt;<span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span>&gt;&gt; &lt;&gt; &lt;&lt;<span style='color:#f67400;'>4</span>,<span style='color:#f67400;'>5</span>&gt;&gt; <span style='color:#7f8c8d;'>#=&gt; &lt;&lt;1,2,3,4,5&gt;&gt;</span>
<span style='color:#da4453;'>&quot;hello &quot;</span> &lt;&gt; <span style='color:#da4453;'>&quot;world&quot;</span>  <span style='color:#7f8c8d;'>#=&gt; &quot;hello world&quot;</span>

<span style='color:#7f8c8d;'># Ranges are represented as `start..end` (both inclusive)</span>
<span style='color:#f67400;'>1</span>..<span style='color:#f67400;'>10</span> <span style='color:#7f8c8d;'>#=&gt; 1..10</span>
lower..upper = <span style='color:#f67400;'>1</span>..<span style='color:#f67400;'>10</span> <span style='color:#7f8c8d;'># Can use pattern matching on ranges as well</span>
<span style='color:#ff9fec;'>[</span>lower, upper<span style='color:#ff9fec;'>]</span> <span style='color:#7f8c8d;'>#=&gt; [1, 10]</span>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Operators</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># Some math</span>
<span style='color:#f67400;'>1</span> + <span style='color:#f67400;'>1</span>  <span style='color:#7f8c8d;'>#=&gt; 2</span>
<span style='color:#f67400;'>10</span> - <span style='color:#f67400;'>5</span> <span style='color:#7f8c8d;'>#=&gt; 5</span>
<span style='color:#f67400;'>5</span> * <span style='color:#f67400;'>2</span>  <span style='color:#7f8c8d;'>#=&gt; 10</span>
<span style='color:#f67400;'>10</span> / <span style='color:#f67400;'>2</span> <span style='color:#7f8c8d;'>#=&gt; 5.0</span>

<span style='color:#7f8c8d;'># In elixir the operator `/` always returns a float.</span>

<span style='color:#7f8c8d;'># To do integer division use `div`</span>
div(<span style='color:#f67400;'>10</span>, <span style='color:#f67400;'>2</span>) <span style='color:#7f8c8d;'>#=&gt; 5</span>

<span style='color:#7f8c8d;'># To get the division remainder use `rem`</span>
rem(<span style='color:#f67400;'>10</span>, <span style='color:#f67400;'>3</span>) <span style='color:#7f8c8d;'>#=&gt; 1</span>

<span style='color:#7f8c8d;'># There are also boolean operators: `or`, `and` and `not`.</span>
<span style='color:#7f8c8d;'># These operators expect a boolean as their first argument.</span>
<b>true</b> <b>and</b> <b>true</b> <span style='color:#7f8c8d;'>#=&gt; true</span>
<b>false</b> <b>or</b> <b>true</b> <span style='color:#7f8c8d;'>#=&gt; true</span>
<span style='color:#7f8c8d;'># 1 and true    #=&gt; ** (ArgumentError) argument error</span>

<span style='color:#7f8c8d;'># Elixir also provides `||`, `&amp;&amp;` and `!` which accept arguments of any type.</span>
<span style='color:#7f8c8d;'># All values except `false` and `nil` will evaluate to true.</span>
<span style='color:#f67400;'>1</span> || <b>true</b>  <span style='color:#7f8c8d;'>#=&gt; 1</span>
<b>false</b> &amp;&amp; <span style='color:#f67400;'>1</span> <span style='color:#7f8c8d;'>#=&gt; false</span>
<b>nil</b> &amp;&amp; <span style='color:#f67400;'>20</span>  <span style='color:#7f8c8d;'>#=&gt; nil</span>
!true <span style='color:#7f8c8d;'>#=&gt; false</span>

<span style='color:#7f8c8d;'># For comparisons we have: `==`, `!=`, `===`, `!==`, `&lt;=`, `&gt;=`, `&lt;` and `&gt;`</span>
<span style='color:#f67400;'>1</span> == <span style='color:#f67400;'>1</span> <span style='color:#7f8c8d;'>#=&gt; true</span>
<span style='color:#f67400;'>1</span> != <span style='color:#f67400;'>1</span> <span style='color:#7f8c8d;'>#=&gt; false</span>
<span style='color:#f67400;'>1</span> &lt; <span style='color:#f67400;'>2</span>  <span style='color:#7f8c8d;'>#=&gt; true</span>

<span style='color:#7f8c8d;'># `===` and `!==` are more strict when comparing integers and floats:</span>
<span style='color:#f67400;'>1</span> == <span style='color:#f67400;'>1.0</span>  <span style='color:#7f8c8d;'>#=&gt; true</span>
<span style='color:#f67400;'>1</span> === <span style='color:#f67400;'>1.0</span> <span style='color:#7f8c8d;'>#=&gt; false</span>

<span style='color:#7f8c8d;'># We can also compare two different data types:</span>
<span style='color:#f67400;'>1</span> &lt; <span style='color:#2980b9;'>:hello</span> <span style='color:#7f8c8d;'>#=&gt; true</span>

<span style='color:#7f8c8d;'># The overall sorting order is defined below:</span>
<span style='color:#7f8c8d;'># number &lt; atom &lt; reference &lt; functions &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</span>

<span style='color:#7f8c8d;'># To quote Joe Armstrong on this: &quot;The actual order is not important,</span>
<span style='color:#7f8c8d;'># but that a total ordering is well defined is important.&quot;</span>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Control Flow</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># `if` expression</span>
<b>if</b> <b>false</b> <b>do</b>
  <span style='color:#da4453;'>&quot;This will never be seen&quot;</span>
<b>else</b>
  <span style='color:#da4453;'>&quot;This will&quot;</span>
<b>end</b>

<span style='color:#7f8c8d;'># There's also `unless`</span>
<b>unless</b> <b>true</b> <b>do</b>
  <span style='color:#da4453;'>&quot;This will never be seen&quot;</span>
<b>else</b>
  <span style='color:#da4453;'>&quot;This will&quot;</span>
<b>end</b>

<span style='color:#7f8c8d;'># Remember pattern matching? Many control-flow structures in elixir rely on it.</span>

<span style='color:#7f8c8d;'># `case` allows us to compare a value against many patterns:</span>
<b>case</b> {<span style='color:#2980b9;'>:one</span>, <span style='color:#2980b9;'>:two</span>} <b>do</b>
  {<span style='color:#2980b9;'>:four</span>, <span style='color:#2980b9;'>:five</span>} -&gt;
    <span style='color:#da4453;'>&quot;This won't match&quot;</span>
  {<span style='color:#2980b9;'>:one</span>, x} -&gt;
    <span style='color:#da4453;'>&quot;This will match and bind `x` to `:two`&quot;</span>
  _ -&gt;
    <span style='color:#da4453;'>&quot;This will match any value&quot;</span>
<b>end</b>

<span style='color:#7f8c8d;'># It's common to bind the value to `_` if we don't need it.</span>
<span style='color:#7f8c8d;'># For example, if only the head of a list matters to us:</span>
<span style='color:#ff9fec;'>[</span>head | _<span style='color:#ff9fec;'>]</span> = <span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span><span style='color:#ff9fec;'>]</span>
head <span style='color:#7f8c8d;'>#=&gt; 1</span>

<span style='color:#7f8c8d;'># For better readability we can do the following:</span>
<span style='color:#ff9fec;'>[</span>head | _tail<span style='color:#ff9fec;'>]</span> = <span style='color:#ff9fec;'>[</span><span style='color:#2980b9;'>:a</span>, <span style='color:#2980b9;'>:b</span>, <span style='color:#2980b9;'>:c</span><span style='color:#ff9fec;'>]</span>
head <span style='color:#7f8c8d;'>#=&gt; :a</span>

<span style='color:#7f8c8d;'># `cond` lets us check for many conditions at the same time.</span>
<span style='color:#7f8c8d;'># Use `cond` instead of nesting many `if` expressions.</span>
<b>cond</b> <b>do</b>
  <span style='color:#f67400;'>1</span> + <span style='color:#f67400;'>1</span> == <span style='color:#f67400;'>3</span> -&gt;
    <span style='color:#da4453;'>&quot;I will never be seen&quot;</span>
  <span style='color:#f67400;'>2</span> * <span style='color:#f67400;'>5</span> == <span style='color:#f67400;'>12</span> -&gt;
    <span style='color:#da4453;'>&quot;Me neither&quot;</span>
  <span style='color:#f67400;'>1</span> + <span style='color:#f67400;'>2</span> == <span style='color:#f67400;'>3</span> -&gt;
    <span style='color:#da4453;'>&quot;But I will&quot;</span>
<b>end</b>

<span style='color:#7f8c8d;'># It is common to set the last condition equal to `true`, which will always match.</span>
<b>cond</b> <b>do</b>
  <span style='color:#f67400;'>1</span> + <span style='color:#f67400;'>1</span> == <span style='color:#f67400;'>3</span> -&gt;
    <span style='color:#da4453;'>&quot;I will never be seen&quot;</span>
  <span style='color:#f67400;'>2</span> * <span style='color:#f67400;'>5</span> == <span style='color:#f67400;'>12</span> -&gt;
    <span style='color:#da4453;'>&quot;Me neither&quot;</span>
  <b>true</b> -&gt;
    <span style='color:#da4453;'>&quot;But I will (this is essentially an else)&quot;</span>
<b>end</b>

<span style='color:#7f8c8d;'># `try/catch` is used to catch values that are thrown, it also supports an</span>
<span style='color:#7f8c8d;'># `after` clause that is invoked whether or not a value is caught.</span>
<b>try</b> <b>do</b>
  <b>throw</b>(<span style='color:#2980b9;'>:hello</span>)
<b>catch</b>
  message -&gt; <span style='color:#da4453;'>&quot;Got </span><span style='color:#27ae60;'>#{</span>message<span style='color:#27ae60;'>}</span><span style='color:#da4453;'>.&quot;</span>
<b>after</b>
  IO.puts(<span style='color:#da4453;'>&quot;I'm the after clause.&quot;</span>)
<b>end</b>
<span style='color:#7f8c8d;'>#=&gt; I'm the after clause</span>
<span style='color:#7f8c8d;'># &quot;Got :hello&quot;</span>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Modules and Functions</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># Anonymous functions (notice the dot)</span>
square = <b>fn</b>(x) -&gt; x * x <b>end</b>
square.(<span style='color:#f67400;'>5</span>) <span style='color:#7f8c8d;'>#=&gt; 25</span>

<span style='color:#7f8c8d;'># They also accept many clauses and guards.</span>
<span style='color:#7f8c8d;'># Guards let you fine tune pattern matching,</span>
<span style='color:#7f8c8d;'># they are indicated by the `when` keyword:</span>
f = <b>fn</b>
  x, y <b>when</b> x &gt; <span style='color:#f67400;'>0</span> -&gt; x + y
  x, y -&gt; x * y
<b>end</b>

f.(<span style='color:#f67400;'>1</span>, <span style='color:#f67400;'>3</span>)  <span style='color:#7f8c8d;'>#=&gt; 4</span>
f.(-<span style='color:#f67400;'>1</span>, <span style='color:#f67400;'>3</span>) <span style='color:#7f8c8d;'>#=&gt; -3</span>

<span style='color:#7f8c8d;'># Elixir also provides many built-in functions.</span>
<span style='color:#7f8c8d;'># These are available in the current scope.</span>
is_number(<span style='color:#f67400;'>10</span>)    <span style='color:#7f8c8d;'>#=&gt; true</span>
is_list(<span style='color:#da4453;'>&quot;hello&quot;</span>) <span style='color:#7f8c8d;'>#=&gt; false</span>
elem({<span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span>}, <span style='color:#f67400;'>0</span>) <span style='color:#7f8c8d;'>#=&gt; 1</span>

<span style='color:#7f8c8d;'># You can group several functions into a module. Inside a module use `def`</span>
<span style='color:#7f8c8d;'># to define your functions.</span>
<b>defmodule</b> <b>Math</b> <b>do</b>
  <b>def</b> sum(a, b) <b>do</b>
    a + b
  <b>end</b>

  <b>def</b> square(x) <b>do</b>
    x * x
  <b>end</b>
<b>end</b>

<b>Math</b>.sum(<span style='color:#f67400;'>1</span>, <span style='color:#f67400;'>2</span>)  <span style='color:#7f8c8d;'>#=&gt; 3</span>
<b>Math</b>.square(<span style='color:#f67400;'>3</span>) <span style='color:#7f8c8d;'>#=&gt; 9</span>

<span style='color:#7f8c8d;'># To compile our simple Math module save it as `math.ex` and use `elixirc`</span>
<span style='color:#7f8c8d;'># in your terminal: elixirc math.ex</span>

<span style='color:#7f8c8d;'># Inside a module we can define functions with `def` and private functions with `defp`.</span>
<span style='color:#7f8c8d;'># A function defined with `def` is available to be invoked from other modules,</span>
<span style='color:#7f8c8d;'># a private function can only be invoked locally.</span>
<b>defmodule</b> <b>PrivateMath</b> <b>do</b>
  <b>def</b> sum(a, b) <b>do</b>
    do_sum(a, b)
  <b>end</b>

  <b>defp</b> do_sum(a, b) <b>do</b>
    a + b
  <b>end</b>
<b>end</b>

<b>PrivateMath</b>.sum(<span style='color:#f67400;'>1</span>, <span style='color:#f67400;'>2</span>)    <span style='color:#7f8c8d;'>#=&gt; 3</span>
<span style='color:#7f8c8d;'># PrivateMath.do_sum(1, 2) #=&gt; ** (UndefinedFunctionError)</span>

<span style='color:#7f8c8d;'># Function declarations also support guards and multiple clauses:</span>
<b>defmodule</b> <b>Geometry</b> <b>do</b>
  <b>def</b> area({<span style='color:#2980b9;'>:rectangle</span>, w, h}) <b>do</b>
    w * h
  <b>end</b>

  <b>def</b> area({<span style='color:#2980b9;'>:circle</span>, r}) <b>when</b> is_number(r) <b>do</b>
    <span style='color:#f67400;'>3.14</span> * r * r
  <b>end</b>
<b>end</b>

<b>Geometry</b>.area({<span style='color:#2980b9;'>:rectangle</span>, <span style='color:#f67400;'>2</span>, <span style='color:#f67400;'>3</span>}) <span style='color:#7f8c8d;'>#=&gt; 6</span>
<b>Geometry</b>.area({<span style='color:#2980b9;'>:circle</span>, <span style='color:#f67400;'>3</span>})       <span style='color:#7f8c8d;'>#=&gt; 28.25999999999999801048</span>
<span style='color:#7f8c8d;'># Geometry.area({:circle, &quot;not_a_number&quot;})</span>
<span style='color:#7f8c8d;'>#=&gt; ** (FunctionClauseError) no function clause matching in Geometry.area/1</span>

<span style='color:#7f8c8d;'># Due to immutability, recursion is a big part of elixir</span>
<b>defmodule</b> <b>Recursion</b> <b>do</b>
  <b>def</b> sum_list(<span style='color:#ff9fec;'>[</span>head | tail<span style='color:#ff9fec;'>]</span>, acc) <b>do</b>
    sum_list(tail, acc + head)
  <b>end</b>

  <b>def</b> sum_list(<span style='color:#ff9fec;'>[]</span>, acc) <b>do</b>
    acc
  <b>end</b>
<b>end</b>

<b>Recursion</b>.sum_list(<span style='color:#ff9fec;'>[</span><span style='color:#f67400;'>1</span>,<span style='color:#f67400;'>2</span>,<span style='color:#f67400;'>3</span><span style='color:#ff9fec;'>]</span>, <span style='color:#f67400;'>0</span>) <span style='color:#7f8c8d;'>#=&gt; 6</span>

<span style='color:#7f8c8d;'># Elixir modules support attributes, there are built-in attributes and you</span>
<span style='color:#7f8c8d;'># may also add custom ones.</span>
<b>defmodule</b> <b>MyMod</b> <b>do</b>
  <span style='color:#27ae60;'>@moduledoc &quot;&quot;&quot;</span>
<span style='color:#7f8c8d;'>  This is a built-in attribute on a example module.</span>
<span style='color:#7f8c8d;'>  </span><span style='color:#27ae60;'>&quot;&quot;&quot;</span>

  <span style='color:#27ae60;'>@my_data</span> <span style='color:#f67400;'>100</span> <span style='color:#7f8c8d;'># This is a custom attribute.</span>
  IO.inspect(<span style='color:#27ae60;'>@my_data</span>) <span style='color:#7f8c8d;'>#=&gt; 100</span>
<b>end</b>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Structs and Exceptions</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># Structs are extensions on top of maps that bring default values,</span>
<span style='color:#7f8c8d;'># compile-time guarantees and polymorphism into Elixir.</span>
<b>defmodule</b> <b>Person</b> <b>do</b>
  <b>defstruct</b> <span style='color:#2980b9;'>name:</span> <b>nil</b>, <span style='color:#2980b9;'>age:</span> <span style='color:#f67400;'>0</span>, <span style='color:#2980b9;'>height:</span> <span style='color:#f67400;'>0</span>
<b>end</b>

joe_info = %<b>Person</b>{ <span style='color:#2980b9;'>name:</span> <span style='color:#da4453;'>&quot;Joe&quot;</span>, <span style='color:#2980b9;'>age:</span> <span style='color:#f67400;'>30</span>, <span style='color:#2980b9;'>height:</span> <span style='color:#f67400;'>180</span> }
<span style='color:#7f8c8d;'>#=&gt; %Person{age: 30, height: 180, name: &quot;Joe&quot;}</span>

<span style='color:#7f8c8d;'># Access the value of name</span>
joe_info.name <span style='color:#7f8c8d;'>#=&gt; &quot;Joe&quot;</span>

<span style='color:#7f8c8d;'># Update the value of age</span>
older_joe_info = %{ joe_info | <span style='color:#2980b9;'>age:</span> <span style='color:#f67400;'>31</span> }
<span style='color:#7f8c8d;'>#=&gt; %Person{age: 31, height: 180, name: &quot;Joe&quot;}</span>

<span style='color:#7f8c8d;'># The `try` block with the `rescue` keyword is used to handle exceptions</span>
<b>try</b> <b>do</b>
  <b>raise</b> <span style='color:#da4453;'>&quot;some error&quot;</span>
<b>rescue</b>
  <b>RuntimeError</b> -&gt; <span style='color:#da4453;'>&quot;rescued a runtime error&quot;</span>
  _error -&gt; <span style='color:#da4453;'>&quot;this will rescue any error&quot;</span>
<b>end</b>
<span style='color:#7f8c8d;'>#=&gt; &quot;rescued a runtime error&quot;</span>

<span style='color:#7f8c8d;'># All exceptions have a message</span>
<b>try</b> <b>do</b>
  <b>raise</b> <span style='color:#da4453;'>&quot;some error&quot;</span>
<b>rescue</b>
  x <b>in</b> <span style='color:#ff9fec;'>[</span><b>RuntimeError</b><span style='color:#ff9fec;'>]</span> -&gt;
    x.message
<b>end</b>
<span style='color:#7f8c8d;'>#=&gt; &quot;some error&quot;</span>

<span style='color:#7f8c8d;'>## ---------------------------</span>
<span style='color:#7f8c8d;'>## -- Concurrency</span>
<span style='color:#7f8c8d;'>## ---------------------------</span>

<span style='color:#7f8c8d;'># Elixir relies on the actor model for concurrency. All we need to write</span>
<span style='color:#7f8c8d;'># concurrent programs in elixir are three primitives: spawning processes,</span>
<span style='color:#7f8c8d;'># sending messages and receiving messages.</span>

<span style='color:#7f8c8d;'># To start a new process we use the `spawn` function, which takes a function</span>
<span style='color:#7f8c8d;'># as argument.</span>
f = <b>fn</b> -&gt; <span style='color:#f67400;'>2</span> * <span style='color:#f67400;'>2</span> <b>end</b> <span style='color:#7f8c8d;'>#=&gt; #Function&lt;erl_eval.20.80484245&gt;</span>
spawn(f) <span style='color:#7f8c8d;'>#=&gt; #PID&lt;0.40.0&gt;</span>

<span style='color:#7f8c8d;'># `spawn` returns a pid (process identifier), you can use this pid to send</span>
<span style='color:#7f8c8d;'># messages to the process. To do message passing we use the `send` operator.</span>
<span style='color:#7f8c8d;'># For all of this to be useful we need to be able to receive messages. This is</span>
<span style='color:#7f8c8d;'># achieved with the `receive` mechanism:</span>

<span style='color:#7f8c8d;'># The `receive do` block is used to listen for messages and process</span>
<span style='color:#7f8c8d;'># them when they are received. A `receive do` block will only</span>
<span style='color:#7f8c8d;'># process one received message. In order to process multiple</span>
<span style='color:#7f8c8d;'># messages, a function with a `receive do` block must recursively</span>
<span style='color:#7f8c8d;'># call itself to get into the `receive do` block again.</span>

<b>defmodule</b> <b>Geometry</b> <b>do</b>
  <b>def</b> area_loop <b>do</b>
    <b>receive</b> <b>do</b>
      {<span style='color:#2980b9;'>:rectangle</span>, w, h} -&gt;
        IO.puts(<span style='color:#da4453;'>&quot;Area = </span><span style='color:#27ae60;'>#{</span>w * h<span style='color:#27ae60;'>}</span><span style='color:#da4453;'>&quot;</span>)
        area_loop()
      {<span style='color:#2980b9;'>:circle</span>, r} -&gt;
        IO.puts(<span style='color:#da4453;'>&quot;Area = </span><span style='color:#27ae60;'>#{</span><span style='color:#f67400;'>3.14</span> * r * r<span style='color:#27ae60;'>}</span><span style='color:#da4453;'>&quot;</span>)
        area_loop()
    <b>end</b>
  <b>end</b>
<b>end</b>

<span style='color:#7f8c8d;'># Compile the module and create a process that evaluates `area_loop` in the shell</span>
pid = spawn(<b>fn</b> -&gt; <b>Geometry</b>.area_loop() <b>end</b>) <span style='color:#7f8c8d;'>#=&gt; #PID&lt;0.40.0&gt;</span>
<span style='color:#7f8c8d;'># Alternatively</span>
pid = spawn(<b>Geometry</b>, <span style='color:#2980b9;'>:area_loop</span>, <span style='color:#ff9fec;'>[]</span>)

<span style='color:#7f8c8d;'># Send a message to `pid` that will match a pattern in the receive statement</span>
send pid, {<span style='color:#2980b9;'>:rectangle</span>, <span style='color:#f67400;'>2</span>, <span style='color:#f67400;'>3</span>}
<span style='color:#7f8c8d;'>#=&gt; Area = 6</span>
<span style='color:#7f8c8d;'>#   {:rectangle,2,3}</span>

send pid, {<span style='color:#2980b9;'>:circle</span>, <span style='color:#f67400;'>2</span>}
<span style='color:#7f8c8d;'>#=&gt; Area = 12.56000000000000049738</span>
<span style='color:#7f8c8d;'>#   {:circle,2}</span>

<span style='color:#7f8c8d;'># The shell is also a process, you can use `self` to get the current pid</span>
self() <span style='color:#7f8c8d;'>#=&gt; #PID&lt;0.27.0&gt;</span>
</pre>
</body>
</html>
